//@version=5
indicator("Optimized NN Showcase | Alien_Algorithms", overlay=true, shorttitle="NN Showcase | AA")

// Inputs
learningRate = input.float(title='Learning Rate', defval=0.1, minval=0.00001)
epochs = input.int(title='Epochs', defval=60, minval=10, maxval=1000)
useSimpleBackprop = input(defval=false, title='Simple Backpropagation')

// Statistics
plotLossCurve = input(true, 'Plot Loss Curve', group='Statistics')
chartScaling = input.int(title='Chart Scaling Factor', defval=1, minval=1, group = 'Statistics')
horizontalOffset = input.int(title='Chart Horizontal Offset', defval = 100, group='Statistics')
verticalOffset = input.int(title='Chart Vertical Offset (%)', defval = -2, group='Statistics')
verticalOffsetPct = 1 + (verticalOffset / 100)

// Max price for normalization
var float maxScale = 0.0
maxScale := math.max(high, maxScale)

// Weight matrices initialization
var matrix<float> W1 = matrix.new<float>(2, 2)
var matrix<float> W2 = matrix.new<float>(1, 2)
if barstate.isfirst
    W1.fill(math.random())
    W2.fill(math.random())

// Declaration of lossCurve globally
var array<float> lossCurve = array.new_float()

// Activation and loss functions
sigmoid(x) => 1 / (1 + math.exp(-x))
mseLoss(predicted, actual) => math.pow(predicted - actual, 2)

// Normalization and standardization
normalize(data) => data / maxScale
standardize(data) => data * maxScale


// Neural network operations
feedforward(input) =>
    var array<float> hiddenOut = array.new_float(2, 0.0)
    for row = 0 to 1
        var sum = 0.0
        for col = 0 to 1
            sum := sum + matrix.get(W1, row, col) * array.get(input, col)
        array.set(hiddenOut, row, sigmoid(sum))
    var outputSum = 0.0
    for col = 0 to 1
        outputSum := outputSum + matrix.get(W2, 0, col) * array.get(hiddenOut, col)
    outputSum := sigmoid(outputSum)
    [outputSum, hiddenOut]

updateWeights(input, actual_output, predicted_output, hidden_out, w1, w2, lr) =>
    var updated_w1 = matrix.new<float>(2, 2)
    var updated_w2 = matrix.new<float>(1, 2)

    // Update weights of the second layer
    for i = 0 to 1
        updated_w2.set(0, i, w2.get(0, i) - lr * 2 * (predicted_output - actual_output) * array.get(hidden_out, i))

    // Update weights of the first layer
    for i = 0 to 1
        for j = 0 to 1
            updated_w1.set(i, j, w1.get(i, j) - lr * 2 * (predicted_output - actual_output) * w2.get(0, i) * array.get(input, j))

    [updated_w1, updated_w2]


// Training wrapper
trainNN(input, actualOutput) =>
    var lossCurve = array.new_float()
    for epoch = 1 to epochs
        [predictedOutput, hiddenOut] = feedforward(input)
        loss = mseLoss(predictedOutput, actualOutput)
        log.warning("~~~~ Epoch {0} ~~~~", epoch)
        log.info("Loss: {0}", str.tostring(loss))
        array.push(lossCurve, loss)
        [W1, W2] = updateWeights(input, actualOutput, predictedOutput, hiddenOut, W1, W2, learningRate)
    lossCurve

// Main script execution
float[] inputData =array.from(normalize(close[1]), normalize(close[2]))
float actualOutput = normalize(close)
float predictedOutput = na
if barstate.islastconfirmedhistory
    lossCurve = trainNN(inputData, actualOutput)
    [predictedOutputNorm, _] = feedforward(inputData)
    predictedOutput := standardize(predictedOutputNorm)


// Visualization
// Helper functions for plotting
plotNeuralOutput(value, label, lineColor) =>
    if not na(value)
        line.new(bar_index, value, bar_index + 40, value, color=lineColor, width=2)
        label.new(bar_index + 40, value, text=label, style=label.style_label_down, color=lineColor)

// Helper function for plotting the loss curve
plotLossCurve(lossCurve, label, lineColor) =>
    var line lineCurve = na
    if array.size(lossCurve) > 0
        lineCurve := line.new(na, na, na, na, color=lineColor, width=1)
        for i = 0 to array.size(lossCurve) - 1
            line.set_xy1(lineCurve, i, array.get(lossCurve, i))



plotNeuralOutput(predictedOutput, "Predicted Output", color.purple)
plotNeuralOutput(standardize(actualOutput), "Actual Output", color.green)
if plotLossCurve
    plotLossCurve(lossCurve, "Loss Curve", color.rgb(194, 208, 0))

